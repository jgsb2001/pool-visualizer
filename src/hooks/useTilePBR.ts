import { useMemo } from 'react';
import * as THREE from 'three';
import { useTileStore } from './useTileStore';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
const textureLoader = new THREE.TextureLoader();

interface TilePBRTextures {
  normalMap: THREE.Texture | null;
  roughnessMap: THREE.Texture | null;
  aoMap: THREE.Texture | null;
}

/**
 * Loads PBR textures (normal, roughness, AO) generated by the server
 * for the first uploaded tile image. These maps add physical surface
 * detail to the waterline tile material â€” visible bumps, varying gloss,
 * and crevice darkening.
 *
 * Uses the first tile's PBR maps since all tiles in the strip share
 * similar surface characteristics. Falls back to null (no PBR maps)
 * if the server hasn't generated maps yet.
 */
export function useTilePBR(): TilePBRTextures {
  const tileImages = useTileStore((s) => s.tileImages);

  // Use the first tile's PBR maps (they share similar surface properties)
  const pbrMaps = tileImages.length > 0 ? tileImages[0].pbrMaps : undefined;

  const normalMap = useMemo(() => {
    if (!pbrMaps?.normal) return null;
    const tex = textureLoader.load(`${API_BASE_URL}${pbrMaps.normal}`);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    return tex;
  }, [pbrMaps?.normal]);

  const roughnessMap = useMemo(() => {
    if (!pbrMaps?.roughness) return null;
    const tex = textureLoader.load(`${API_BASE_URL}${pbrMaps.roughness}`);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    return tex;
  }, [pbrMaps?.roughness]);

  const aoMap = useMemo(() => {
    if (!pbrMaps?.ao) return null;
    const tex = textureLoader.load(`${API_BASE_URL}${pbrMaps.ao}`);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.ClampToEdgeWrapping;
    return tex;
  }, [pbrMaps?.ao]);

  return { normalMap, roughnessMap, aoMap };
}
